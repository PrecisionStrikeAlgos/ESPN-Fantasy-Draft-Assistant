<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Draft Assistant Pro</title>
    <style>
        :root {
            --primary-blue: #1a237e;
            --secondary-blue: #3949ab;
            --accent-orange: #ff6f00;
            --success-green: #2e7d32;
            --warning-red: #c62828;
            --dark-bg: #0d1117;
            --card-bg: #161b22;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #7d8590;
            --hover-bg: #21262d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--dark-bg);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: grid;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
        }

        .header {
            background: var(--primary-blue);
            padding: 1rem 2rem;
            border-bottom: 3px solid var(--accent-orange);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 2rem;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* Setup Screens */
        .setup-screen {
            display: none;
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .setup-screen.active {
            display: block;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--accent-orange);
            font-weight: 600;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--dark-bg);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--secondary-blue);
            box-shadow: 0 0 0 3px rgba(57, 73, 171, 0.2);
        }

        .btn {
            background: var(--accent-orange);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn:hover {
            background: #e65100;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 111, 0, 0.3);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: var(--secondary-blue);
        }

        .btn.secondary:hover {
            background: #303f9f;
        }

        .team-setup {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .team-input {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.8rem;
            background: var(--hover-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .draft-order {
            width: 60px;
            text-align: center;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 50%;
            font-weight: bold;
        }

        /* Main Draft Interface */
        .draft-interface {
            display: none;
            grid-template-rows: auto 1fr;
            height: calc(100vh - 80px);
        }

        .draft-interface.active {
            display: grid;
        }

        .draft-controls {
            background: var(--card-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 2rem;
            align-items: center;
        }

        .timer-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .draft-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .timer {
            background: var(--warning-red);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
        }

        .timer.paused {
            background: #666;
        }

        .current-pick {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-orange);
        }

        .my-picks-tracker {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.3rem;
        }

        .my-picks-tracker span {
            color: var(--accent-orange);
            font-weight: bold;
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 1rem;
            padding: 1rem;
            height: calc(100vh - 140px);
            overflow: hidden;
        }

        .draft-board-container {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .draft-board-header {
            background: var(--primary-blue);
            padding: 1rem;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .draft-board {
            flex: 1;
            overflow: auto;
            padding: 1rem;
            padding-bottom: 2rem;
            max-height: calc(100vh - 220px);
        }

        .draft-grid {
            display: grid;
            grid-template-columns: 60px repeat(var(--team-count, 10), 1fr);
            gap: 2px;
            min-width: fit-content;
        }

        .round-header, .team-header {
            background: var(--secondary-blue);
            padding: 0.5rem;
            text-align: center;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
        }

        .draft-slot {
            background: var(--hover-bg);
            border: 1px solid var(--border-color);
            min-height: 60px;
            padding: 0.5rem;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .draft-slot.current {
            background: var(--accent-orange);
            color: white;
            box-shadow: 0 0 10px rgba(255, 111, 0, 0.5);
            animation: pulse 2s infinite;
        }

        .draft-slot.filled {
            background: var(--success-green);
            color: white;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 0.2rem;
        }

        .player-details {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: calc(100vh - 140px);
            overflow: hidden;
        }

        /* AI Recommendations Panel */
        .ai-recommendations {
            background: var(--card-bg);
            border-radius: 12px;
            border: 2px solid var(--accent-orange);
            margin-bottom: 1rem;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255, 111, 0, 0.2);
            max-height: 400px;
            flex-shrink: 0;
        }

        .ai-header {
            background: linear-gradient(135deg, var(--accent-orange), #e65100);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-header h3 {
            color: white;
            font-size: 1.1rem;
            margin: 0;
        }

        .ai-status {
            background: rgba(255,255,255,0.2);
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            color: white;
        }

        .ai-content {
            padding: 1rem;
            max-height: 320px;
            overflow-y: auto;
        }

        .top-picks {
            margin-bottom: 1rem;
        }

        .ai-pick {
            background: var(--hover-bg);
            border-radius: 8px;
            padding: 0.8rem;
            margin-bottom: 0.5rem;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .ai-pick.must-draft {
            border-left-color: var(--success-green);
            background: rgba(46, 125, 50, 0.1);
        }

        .ai-pick.good-value {
            border-left-color: #ffa726;
            background: rgba(255, 167, 38, 0.1);
        }

        .ai-pick.avoid {
            border-left-color: var(--warning-red);
            background: rgba(198, 40, 40, 0.1);
        }

        .ai-pick:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .ai-pick-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .ai-pick-name {
            font-weight: bold;
            font-size: 0.95rem;
        }

        .ai-pick-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .ai-pick-badge.must-draft {
            background: var(--success-green);
            color: white;
        }

        .ai-pick-badge.good-value {
            background: #ffa726;
            color: white;
        }

        .ai-pick-badge.avoid {
            background: var(--warning-red);
            color: white;
        }

        .ai-pick-reason {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        .ai-pick-stats {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.3rem;
        }

        .draft-insights {
            border-top: 1px solid var(--border-color);
            padding-top: 1rem;
        }

        .insight-item {
            background: var(--hover-bg);
            padding: 0.6rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            border-left: 3px solid var(--secondary-blue);
        }

        .insight-item.alert {
            border-left-color: var(--warning-red);
            background: rgba(198, 40, 40, 0.1);
        }

        .insight-item.opportunity {
            border-left-color: var(--success-green);
            background: rgba(46, 125, 50, 0.1);
        }

        .player-pool {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .player-pool-header {
            background: var(--secondary-blue);
            padding: 1rem;
            border-radius: 12px 12px 0 0;
        }

        .search-container {
            margin-top: 1rem;
        }

        .search-box {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--dark-bg);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .position-tabs {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .position-tab {
            padding: 0.5rem 1rem;
            background: var(--hover-bg);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .position-tab.active {
            background: var(--accent-orange);
            color: white;
        }

        .players-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            padding-bottom: 2rem;
            max-height: calc(100vh - 420px);
            min-height: 300px;
        }

        .player-card {
            background: var(--hover-bg);
            margin-bottom: 0.8rem;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--secondary-blue);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-card:hover {
            background: var(--border-color);
            transform: translateX(5px);
        }

        .player-card.drafted {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .player-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .player-info {
            font-weight: bold;
            font-size: 1rem;
        }

        .player-stats {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .draft-player-btn {
            background: var(--success-green);
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .draft-player-btn:hover {
            background: #1b5e20;
        }

        .draft-player-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .status-message {
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }

        .status-success {
            background: rgba(46, 125, 50, 0.2);
            border: 1px solid var(--success-green);
            color: #81c784;
        }

        .status-error {
            background: rgba(198, 40, 40, 0.2);
            border: 1px solid var(--warning-red);
            color: #ef5350;
        }

        .status-loading {
            background: rgba(255, 111, 0, 0.2);
            border: 1px solid var(--accent-orange);
            color: #ffb74d;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }
            
            .sidebar {
                max-height: 300px;
            }
        }

        @media (max-width: 768px) {
            .draft-controls {
                grid-template-columns: 1fr;
                gap: 1rem;
                text-align: center;
            }
            
            .team-setup {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
        }

        .hidden {
            display: none !important;
        }

        /* Loading Spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üèà Fantasy Draft Assistant Pro</h1>
        </div>

        <!-- ESPN Connection Screen -->
        <div class="setup-screen active" id="connectionScreen">
            <h2 style="margin-bottom: 2rem; text-align: center; color: var(--accent-orange);">ESPN League Connection</h2>
            
            <div class="form-group">
                <label for="leagueId">ESPN League ID *</label>
                <input type="number" id="leagueId" placeholder="Enter your League ID" required>
                <small style="color: var(--text-secondary); font-size: 0.8rem;">Find this in your ESPN league URL</small>
            </div>
            
            <div class="form-group">
                <label for="seasonId">Season Year *</label>
                <input type="number" id="seasonId" value="2025" required>
            </div>

            <div class="form-group">
                <label for="espnS2">ESPN_S2 Cookie (Private Leagues)</label>
                <input type="password" id="espnS2" placeholder="Optional - for private leagues">
                <small style="color: var(--text-secondary); font-size: 0.8rem;">Find in browser dev tools if your league is private</small>
            </div>

            <div class="form-group">
                <label for="swid">SWID Cookie (Private Leagues)</label>
                <input type="password" id="swid" placeholder="Optional - for private leagues">
            </div>

            <button class="btn" onclick="connectToESPN()" id="connectBtn">
                Connect to ESPN League
            </button>

            <div class="status-message hidden" id="connectionStatus"></div>
        </div>

        <!-- League Setup Screen -->
        <div class="setup-screen" id="leagueSetupScreen">
            <h2 style="margin-bottom: 2rem; text-align: center; color: var(--accent-orange);">League Setup</h2>
            
            <div class="form-group">
                <label for="leagueSize">League Size</label>
                <select id="leagueSize" onchange="updateTeamInputs()">
                    <option value="10">10 Teams</option>
                    <option value="12">12 Teams</option>
                </select>
            </div>

            <div class="form-group">
                <label for="myDraftPosition">My Draft Position</label>
                <select id="myDraftPosition">
                    <option value="1">1st Pick</option>
                    <option value="2">2nd Pick</option>
                    <option value="3">3rd Pick</option>
                    <option value="4">4th Pick</option>
                    <option value="5">5th Pick</option>
                    <option value="6">6th Pick</option>
                    <option value="7">7th Pick</option>
                    <option value="8">8th Pick</option>
                    <option value="9">9th Pick</option>
                    <option value="10">10th Pick</option>
                    <option value="11">11th Pick</option>
                    <option value="12">12th Pick</option>
                </select>
            </div>

            <h3 style="margin: 2rem 0 1rem 0; color: var(--secondary-blue);">Team Names & Draft Order</h3>
            <div class="team-setup" id="teamSetup">
                <!-- Team inputs will be generated here -->
            </div>

            <div style="margin-top: 2rem; display: flex; gap: 1rem; justify-content: center;">
                <button class="btn secondary" onclick="goToConnection()">Back</button>
                <button class="btn" onclick="saveLeagueSetup()">Start Draft</button>
            </div>
        </div>

        <!-- Main Draft Interface -->
        <div class="draft-interface" id="draftInterface">
                                <div class="draft-controls">
                <div class="draft-status">
                    <div class="current-pick" id="currentPick">Round 1, Pick 1 - Team Name</div>
                    <div class="my-picks-tracker" id="myPicksTracker">
                        <strong>My Picks:</strong> <span id="myPickCount">0</span> | 
                        <strong>Next Pick:</strong> <span id="myNextPick">Round 1, Pick ?</span>
                    </div>
                </div>
                <div class="timer-controls">
                    <div class="timer" id="timer">2:00</div>
                    <button class="btn secondary" onclick="pauseTimer()" id="pauseBtn">Pause</button>
                    <button class="btn" onclick="restartTimer()">Restart</button>
                    <button class="btn" onclick="nextPick()" style="background: var(--success-green); margin-left: 0.5rem;">Next Pick</button>
                </div>
                <button class="btn" onclick="resetDraft()" style="background: var(--warning-red); padding: 0.5rem 1rem; font-size: 0.9rem;">üóëÔ∏è New</button>
            </div>

            <div class="main-content">
                <div class="draft-board-container">
                    <div class="draft-board-header">
                        <h3>Draft Board</h3>
                    </div>
                    <div class="draft-board">
                        <div class="draft-grid" id="draftGrid">
                            <!-- Draft grid will be generated here -->
                        </div>
                    </div>
                </div>

                <div class="sidebar">
                    <!-- AI RECOMMENDATIONS PANEL -->
                    <div class="ai-recommendations">
                        <div class="ai-header">
                            <h3>üß† AI Draft Assistant</h3>
                            <div class="ai-status" id="aiStatus">Analyzing...</div>
                        </div>
                        <div class="ai-content">
                            <div class="top-picks" id="topPicks">
                                <!-- AI recommendations will populate here -->
                            </div>
                            <div class="draft-insights" id="draftInsights">
                                <!-- Real-time insights will populate here -->
                            </div>
                        </div>
                    </div>

                    <div class="player-pool">
                        <div class="player-pool-header">
                            <h3>Player Pool</h3>
                            <div class="search-container">
                                <input type="text" class="search-box" id="playerSearch" placeholder="Search players..." oninput="searchPlayers()">
                            </div>
                            <div class="position-tabs" id="positionTabs">
                                <div class="position-tab active" data-position="ALL">All</div>
                                <div class="position-tab" data-position="1">QB</div>
                                <div class="position-tab" data-position="2">RB</div>
                                <div class="position-tab" data-position="3">WR</div>
                                <div class="position-tab" data-position="4">TE</div>
                                <div class="position-tab" data-position="5">K</div>
                                <div class="position-tab" data-position="16">D/ST</div>
                            </div>
                        </div>
                        <div class="players-list" id="playersList">
                            <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                                Loading players...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // AI RECOMMENDATION ENGINE
        let aiEngine = {
            // Position tiers based on 2025 data
            tiers: {
                RB: {
                    elite: ['Christian McCaffrey', 'Saquon Barkley', 'Bijan Robinson'],
                    tier1: ['Derrick Henry', 'Joe Mixon', 'Kyren Williams', 'Jonathan Taylor'],
                    tier2: ['Josh Jacobs', 'Breece Hall', 'De\'Von Achane', 'James Conner'],
                    tier3: ['Aaron Jones', 'Rachaad White', 'Tony Pollard', 'Najee Harris']
                },
                WR: {
                    elite: ['CeeDee Lamb', 'Tyreek Hill', 'Amon-Ra St. Brown', 'A.J. Brown'],
                    tier1: ['Ja\'Marr Chase', 'Justin Jefferson', 'Davante Adams', 'Mike Evans'],
                    tier2: ['DK Metcalf', 'Amari Cooper', 'DeVonta Smith', 'Tee Higgins'],
                    tier3: ['Calvin Ridley', 'Diontae Johnson', 'Tyler Lockett', 'Courtland Sutton']
                },
                TE: {
                    elite: ['Travis Kelce', 'Mark Andrews'],
                    tier1: ['Trey McBride', 'Brock Bowers', 'George Kittle'],
                    tier2: ['Sam LaPorta', 'Evan Engram', 'Kyle Pitts'],
                    tier3: ['David Njoku', 'Dallas Goedert', 'Jake Ferguson']
                },
                QB: {
                    elite: ['Josh Allen', 'Lamar Jackson', 'Jalen Hurts', 'Jayden Daniels'],
                    tier1: ['Joe Burrow', 'Dak Prescott', 'Baker Mayfield', 'Kyler Murray'],
                    tier2: ['Justin Herbert', 'Tua Tagovailoa', 'Justin Fields', 'Caleb Williams']
                }
            },

            // Your specific strategy preferences
            strategy: {
                rounds: {
                    early: [1, 2, 3, 4, 5], // RB/WR focus
                    teMid: [6, 7, 8], // TE target zone
                    late: [9, 10, 11, 12, 13, 14, 15, 16] // QB/K/DST
                },
                positionalPreference: {
                    1: ['RB', 'WR'], // Round 1-2: Skill positions only
                    2: ['RB', 'WR'],
                    3: ['RB', 'WR'],
                    4: ['RB', 'WR'],
                    5: ['RB', 'WR'],
                    6: ['TE', 'RB', 'WR'], // TE window opens
                    7: ['TE', 'RB', 'WR'],
                    8: ['TE', 'RB', 'WR', 'QB'], // Late QB if elite
                    9: ['QB', 'RB', 'WR'],
                    10: ['QB', 'RB', 'WR'],
                    11: ['QB', 'RB', 'WR'],
                    12: ['QB', 'K', 'D/ST'],
                    13: ['K', 'D/ST'],
                    14: ['K', 'D/ST'],
                    15: ['K', 'D/ST'],
                    16: ['K', 'D/ST']
                }
            },

            // Calculate Value Over Replacement Plus - FIXED
            calculateVORPlus: function(player, currentRound) {
                // Debug logging
                console.log(`Calculating VOR for ${player.name}: Proj=${player.projectedPoints}, Pos=${player.position}, Round=${currentRound}`);
                
                const baselines = {
                    QB: { points: 280, adp: 90 },
                    RB: { points: 200, adp: 30 },
                    WR: { points: 180, adp: 35 },
                    TE: { points: 140, adp: 70 },
                    K: { points: 120, adp: 150 },
                    'D/ST': { points: 110, adp: 160 }
                };

                const baseline = baselines[player.position] || baselines.RB;
                
                // Ensure we have valid numbers
                const projectedPoints = parseFloat(player.projectedPoints) || 0;
                const playerADP = parseFloat(player.adp) || 999;
                
                // For late round players with low projections, use a minimum baseline
                const adjustedBaseline = Math.min(baseline.points, projectedPoints * 0.5);
                const rawVOR = Math.max(0, projectedPoints - adjustedBaseline);
                
                // ADP value gap (steal detection)
                const expectedPick = currentRound * 12;
                let adpMultiplier = 1.0;
                if (playerADP < 500) {
                    const adpGap = playerADP - expectedPick;
                    adpMultiplier = adpGap > 24 ? 0.8 : adpGap > 12 ? 0.9 : adpGap > 0 ? 1.0 : adpGap > -12 ? 1.2 : 1.4;
                }
                
                // Position scarcity multiplier
                const scarcityMultiplier = this.getScarcityMultiplier(player.position, currentRound);
                
                // Early round RB/WR bonus for your strategy
                let strategyBonus = 1.0;
                if (currentRound <= 5 && ['RB', 'WR'].includes(player.position)) {
                    strategyBonus = 1.3; // Your "killers first" preference
                }
                
                const finalVOR = Math.max(0.1, rawVOR * adpMultiplier * scarcityMultiplier * strategyBonus);
                
                console.log(`${player.name} VOR: ${rawVOR.toFixed(1)} * ${adpMultiplier.toFixed(1)} * ${scarcityMultiplier.toFixed(1)} * ${strategyBonus.toFixed(1)} = ${finalVOR.toFixed(1)}`);
                
                return finalVOR;
            },

            getScarcityMultiplier: function(position, round) {
                const multipliers = {
                    QB: round > 8 ? 1.4 : 0.6, // Heavy late QB boost, early penalty
                    RB: round <= 3 ? 1.4 : round <= 6 ? 1.2 : round <= 10 ? 1.0 : 0.8, // Early RB priority
                    WR: round <= 3 ? 1.3 : round <= 6 ? 1.2 : round <= 10 ? 1.0 : 0.8, // Early WR priority  
                    TE: round >= 6 && round <= 8 ? 1.5 : round > 8 ? 0.7 : 0.8, // TE sweet spot rounds 6-8
                    K: round > 13 ? 1.0 : 0.1, // Only valuable very late
                    'D/ST': round > 12 ? 1.0 : 0.1 // Only valuable late
                };
                return multipliers[position] || 1.0;
            },

            // Generate AI recommendations
            generateRecommendations: function() {
                const currentRound = appState.currentRound;
                const availablePlayers = this.getAvailablePlayers();
                const myRoster = this.getMyCurrentRoster();
                const rosterNeeds = this.analyzeRosterNeeds(myRoster, currentRound);
                
                // Filter out obvious bad picks early - don't even show them
                const viablePlayers = availablePlayers.filter(player => {
                    // Filter out K/D/ST in early rounds
                    if (currentRound <= 12 && ['K', 'D/ST'].includes(player.position)) {
                        return false;
                    }
                    // Filter out QB in very early rounds unless critical need
                    if (currentRound <= 6 && player.position === 'QB' && rosterNeeds.QB !== 'CRITICAL') {
                        return false;
                    }
                    return true;
                });
                
                // Score all viable players
                const scoredPlayers = viablePlayers.map(player => {
                    const vorPlus = this.calculateVORPlus(player, currentRound);
                    const strategyFit = this.getStrategyFit(player, currentRound, rosterNeeds);
                    const finalScore = vorPlus * strategyFit;
                    
                    return {
                        ...player,
                        vorPlus,
                        strategyFit,
                        finalScore,
                        recommendation: this.getRecommendationType(player, currentRound, finalScore, rosterNeeds)
                    };
                }).sort((a, b) => b.finalScore - a.finalScore);
                
                // Return top 5 VIABLE recommendations only
                return scoredPlayers.slice(0, 5);
            },

            getAvailablePlayers: function() {
                return appState.currentPlayers.filter(player => {
                    return !appState.draftPicks.some(pick => pick.playerId === player.id);
                });
            },

            getMyCurrentRoster: function() {
                const teamCount = appState.leagueSetup.size;
                const myDraftPosition = appState.leagueSetup.myDraftPosition;
                
                return appState.draftPicks.filter(pick => {
                    const pickTeamIndex = this.getPickTeamIndex(pick.overallPick, teamCount);
                    return pickTeamIndex === myDraftPosition;
                });
            },

            getPickTeamIndex: function(overallPick, teamCount) {
                const round = Math.ceil(overallPick / teamCount);
                const pickInRound = ((overallPick - 1) % teamCount) + 1;
                const isSnakeRound = round % 2 === 0;
                
                return isSnakeRound ? teamCount - pickInRound : pickInRound - 1;
            },

            analyzeRosterNeeds: function(roster, currentRound) {
                const positionCounts = { QB: 0, RB: 0, WR: 0, TE: 0, K: 0, 'D/ST': 0 };
                
                roster.forEach(pick => {
                    const player = appState.currentPlayers.find(p => p.id === pick.playerId);
                    if (player) {
                        positionCounts[player.position] = (positionCounts[player.position] || 0) + 1;
                    }
                });
                
                console.log(`üèà MY ROSTER ANALYSIS: QB:${positionCounts.QB}, RB:${positionCounts.RB}, WR:${positionCounts.WR}, TE:${positionCounts.TE}, K:${positionCounts.K}, DST:${positionCounts['D/ST']}`);
                
                // Standard fantasy lineup: 1 QB, 2 RB, 2 WR, 1 TE, 1 FLEX, 1 K, 1 D/ST
                // FLEX can be RB/WR/TE, so we need 3+ RB+WR combined for starters
                const flexEligible = positionCounts.RB + positionCounts.WR + positionCounts.TE;
                
                const needs = {
                    // QB: Need 1 starter + 1 backup
                    QB: currentRound >= 9 && positionCounts.QB === 0 ? 'HIGH' : 
                        currentRound >= 12 && positionCounts.QB < 2 ? 'MEDIUM' : 'LOW',
                    
                    // RB: Need 2 starters + FLEX eligibility + depth (4-5 total)
                    RB: positionCounts.RB === 0 ? 'CRITICAL' :
                        positionCounts.RB === 1 ? 'HIGH' :
                        positionCounts.RB < 3 ? 'MEDIUM' : 
                        positionCounts.RB < 5 ? 'LOW' : 'SATISFIED',
                    
                    // WR: Need 2 starters + FLEX eligibility + depth (4-5 total)
                    WR: positionCounts.WR === 0 ? 'CRITICAL' :
                        positionCounts.WR === 1 ? 'HIGH' :
                        positionCounts.WR < 3 ? 'MEDIUM' :
                        positionCounts.WR < 5 ? 'LOW' : 'SATISFIED',
                    
                    // TE: Need 1 starter + 1 backup (2 total) - FIXED LOGIC
                    TE: positionCounts.TE === 0 && currentRound >= 6 && currentRound <= 8 ? 'HIGH' :
                        positionCounts.TE === 0 && currentRound > 8 ? 'MEDIUM' :
                        positionCounts.TE === 1 && currentRound > 10 ? 'LOW' : 
                        positionCounts.TE >= 2 ? 'SATISFIED' : 'LOW',
                    
                    // K & D/ST: Need 1 each, draft late
                    K: currentRound >= 14 && positionCounts.K === 0 ? 'HIGH' : 
                       positionCounts.K >= 1 ? 'SATISFIED' : 'LOW',
                    'D/ST': currentRound >= 13 && positionCounts['D/ST'] === 0 ? 'HIGH' : 
                            positionCounts['D/ST'] >= 1 ? 'SATISFIED' : 'LOW'
                };
                
                // FLEX consideration: If we have < 3 RB+WR+TE, prioritize skill positions
                if (flexEligible < 3 && currentRound <= 8) {
                    if (positionCounts.RB < positionCounts.WR) {
                        needs.RB = 'HIGH';
                    } else {
                        needs.WR = 'HIGH';
                    }
                }
                
                console.log(`üéØ NEEDS ANALYSIS:`, needs);
                
                return needs;
            },

            getStrategyFit: function(player, currentRound, rosterNeeds) {
                let fit = 1.0;
                
                // Position strategy fit
                const preferredPositions = this.strategy.positionalPreference[Math.min(currentRound, 16)] || [];
                if (preferredPositions.includes(player.position)) {
                    fit *= 1.3;
                } else if (!preferredPositions.includes(player.position)) {
                    fit *= 0.6;
                }
                
                // Roster need multiplier - updated for actual fantasy lineup
                const needMultipliers = { 
                    CRITICAL: 2.0,  // Must fill this position NOW
                    HIGH: 1.4, 
                    MEDIUM: 1.1, 
                    LOW: 0.9,
                    SATISFIED: 0.7
                };
                fit *= needMultipliers[rosterNeeds[player.position]] || 1.0;
                
                // TE strategy bonus (rounds 6-8) - your sweet spot
                if (player.position === 'TE' && currentRound >= 6 && currentRound <= 8) {
                    fit *= 1.6; // Even higher bonus for your TE preference
                }
                
                // FLEX value bonus - RB/WR/TE all fill FLEX
                if (['RB', 'WR', 'TE'].includes(player.position) && currentRound <= 10) {
                    fit *= 1.1; // Slight bonus for FLEX eligibility
                }
                
                // Early round skill position bonus (your strategy)
                if (['RB', 'WR'].includes(player.position) && currentRound <= 5) {
                    fit *= 1.2; // Matches your "killers first" approach
                }
                
                return fit;
            },

            getRecommendationType: function(player, currentRound, finalScore, rosterNeeds) {
                const need = rosterNeeds[player.position];
                
                // CRITICAL need - must fill position NOW
                if (need === 'CRITICAL') {
                    return {
                        type: 'must-draft',
                        label: 'CRITICAL NEED',
                        reason: `Must fill ${player.position} - you have ZERO at this position!`
                    };
                }
                
                // Must draft: High VOR+ and strategy fit, or high need
                if ((finalScore > 50 && need === 'HIGH') || finalScore > 80) {
                    return {
                        type: 'must-draft',
                        label: 'MUST DRAFT',
                        reason: finalScore > 80 ? `Elite value for Round ${currentRound}!` : 
                               `Perfect ${player.position} value to fill lineup need`
                    };
                }
                
                // Good value: Above average VOR+ or filling important need
                if (finalScore > 25 || ['HIGH', 'MEDIUM'].includes(need)) {
                    let reason = '';
                    if (finalScore > 25 && need === 'HIGH') {
                        reason = `Great value + fills ${player.position} need`;
                    } else if (finalScore > 25) {
                        reason = 'Excellent value vs ADP';
                    } else {
                        reason = `Solid option to fill ${player.position} need`;
                    }
                    
                    return {
                        type: 'good-value',
                        label: 'GOOD VALUE',
                        reason: reason
                    };
                }
                
                // Since we pre-filtered, everything else is at least decent
                return {
                    type: 'good-value',
                    label: 'SOLID PICK',
                    reason: `Best available ${player.position} for Round ${currentRound}`
                };
            },

            // Generate real-time insights
            generateInsights: function() {
                const insights = [];
                const currentRound = appState.currentRound;
                const recentPicks = appState.draftPicks.slice(-6);
                
                // Position run detection
                const recentPositions = recentPicks.map(pick => {
                    const player = appState.currentPlayers.find(p => p.id === pick.playerId);
                    return player ? player.position : null;
                }).filter(pos => pos);
                
                const positionCounts = {};
                recentPositions.forEach(pos => {
                    positionCounts[pos] = (positionCounts[pos] || 0) + 1;
                });
                
                // RB run alert
                if (positionCounts.RB >= 3) {
                    insights.push({
                        type: 'alert',
                        text: 'üö® RB RUN! Consider grabbing RB depth now'
                    });
                }
                
                // TE opportunity window
                if (currentRound >= 6 && currentRound <= 8) {
                    const availableEliteTEs = this.getAvailablePlayers().filter(p => 
                        p.position === 'TE' && this.tiers.TE.tier1.includes(p.name)
                    );
                    
                    if (availableEliteTEs.length > 0) {
                        insights.push({
                            type: 'opportunity',
                            text: `üéØ PERFECT TE WINDOW! ${availableEliteTEs[0].name} available`
                        });
                    }
                }
                
                // FLEX eligibility insights
                const myRoster = this.getMyCurrentRoster();
                const myPositionCounts = { QB: 0, RB: 0, WR: 0, TE: 0, K: 0, 'D/ST': 0 };
                
                myRoster.forEach(pick => {
                    const player = appState.currentPlayers.find(p => p.id === pick.playerId);
                    if (player) {
                        myPositionCounts[player.position] = (myPositionCounts[player.position] || 0) + 1;
                    }
                });
                
                const flexEligible = myPositionCounts.RB + myPositionCounts.WR + myPositionCounts.TE;
                
                // FLEX lineup warning
                if (flexEligible < 3 && currentRound >= 6) {
                    insights.push({
                        type: 'alert',
                        text: `‚ö†Ô∏è LINEUP ALERT: Need ${3 - flexEligible} more RB/WR/TE for full lineup`
                    });
                }
                
                // Starter position warnings
                if (myPositionCounts.RB < 2 && currentRound >= 8) {
                    insights.push({
                        type: 'alert',
                        text: `üèÉ RB SHORTAGE: Only ${myPositionCounts.RB} RB, need 2+ for lineup`
                    });
                }
                
                if (myPositionCounts.WR < 2 && currentRound >= 8) {
                    insights.push({
                        type: 'alert',
                        text: `üì° WR SHORTAGE: Only ${myPositionCounts.WR} WR, need 2+ for lineup`
                    });
                }
                const availablePlayers = this.getAvailablePlayers();
                const steals = availablePlayers.filter(player => {
                    return player.adp > 0 && (currentRound * 12) > (player.adp + 24);
                });
                
                if (steals.length > 0) {
                    insights.push({
                        type: 'opportunity',
                        text: `üíé STEAL ALERT: ${steals[0].name} fell 2+ rounds!`
                    });
                }
                
                return insights;
            }
        };

        // Update AI recommendations
        function updateAIRecommendations() {
            if (!appState.currentPlayers.length) return;
            
            try {
                const recommendations = aiEngine.generateRecommendations();
                const insights = aiEngine.generateInsights();
                
                renderAIRecommendations(recommendations);
                renderAIInsights(insights);
                
                document.getElementById('aiStatus').textContent = 'Active';
            } catch (error) {
                console.error('AI recommendation error:', error);
                document.getElementById('aiStatus').textContent = 'Error';
            }
        }

        function renderAIRecommendations(recommendations) {
            const topPicks = document.getElementById('topPicks');
            
            if (!recommendations.length) {
                topPicks.innerHTML = '<div style="text-align: center; color: var(--text-secondary);">No recommendations available</div>';
                return;
            }
            
            const html = recommendations.map(player => `
                <div class="ai-pick ${player.recommendation.type}" onclick="draftPlayer(${player.id})" data-player-id="${player.id}">
                    <div class="ai-pick-header">
                        <div class="ai-pick-name">${player.name} (${player.team} ${player.position})</div>
                        <div class="ai-pick-badge ${player.recommendation.type}">${player.recommendation.label}</div>
                    </div>
                    <div class="ai-pick-reason">${player.recommendation.reason}</div>
                    <div class="ai-pick-stats">
                        ADP: ${player.adp !== 999 ? player.adp.toFixed(1) : 'N/A'} | 
                        Proj: ${player.projectedPoints.toFixed(1)} | 
                        VOR+: ${(player.vorPlus || 0).toFixed(1)}
                    </div>
                </div>
            `).join('');
            
            topPicks.innerHTML = html;
        }

        function renderAIInsights(insights) {
            const draftInsights = document.getElementById('draftInsights');
            
            if (!insights.length) {
                draftInsights.innerHTML = '<div style="font-size: 0.8rem; color: var(--text-secondary); text-align: center;">Monitoring draft trends...</div>';
                return;
            }
            
            const html = insights.map(insight => `
                <div class="insight-item ${insight.type}">
                    ${insight.text}
                </div>
            `).join('');
            
            draftInsights.innerHTML = html;
        }
        let appState = {
            connection: null,
            leagueSetup: null,
            currentPlayers: [],
            draftPicks: [],
            draftTimer: null,
            timerSeconds: 120,
            timerPaused: false,
            currentRound: 1,
            currentPick: 1,
            selectedPosition: 'ALL',
            searchTerm: ''
        };

        // Load saved state on page load
        window.addEventListener('load', loadSavedState);

        function loadSavedState() {
            const savedState = localStorage.getItem('draftAssistantState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    
                    // Restore connection info
                    if (state.connection) {
                        document.getElementById('leagueId').value = state.connection.leagueId || '';
                        document.getElementById('seasonId').value = state.connection.seasonId || '2025';
                        document.getElementById('espnS2').value = state.connection.espnS2 || '';
                        document.getElementById('swid').value = state.connection.swid || '';
                        appState.connection = state.connection;
                    }
                    
                    // Restore league setup
                    if (state.leagueSetup) {
                        appState.leagueSetup = state.leagueSetup;
                        document.getElementById('leagueSize').value = state.leagueSetup.size;
                        updateTeamInputs();
                        
                        // Restore team names
                        state.leagueSetup.teams.forEach((team, index) => {
                            const teamInput = document.querySelector(`input[data-team="${index}"]`);
                            if (teamInput) teamInput.value = team.name;
                        });
                    }
                    
                    // Restore draft state
                    if (state.draftPicks) {
                        appState.draftPicks = state.draftPicks;
                        appState.currentRound = state.currentRound || 1;
                        appState.currentPick = state.currentPick || 1;
                    }
                    
                    console.log('‚úÖ State restored from localStorage');
                } catch (error) {
                    console.error('‚ùå Failed to restore state:', error);
                }
            }
        }

        function saveState() {
            try {
                const stateToSave = {
                    connection: appState.connection,
                    leagueSetup: appState.leagueSetup,
                    draftPicks: appState.draftPicks,
                    currentRound: appState.currentRound,
                    currentPick: appState.currentPick,
                    timerSeconds: appState.timerSeconds,
                    timerPaused: appState.timerPaused,
                    timerStartTime: appState.timerStartTime,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem('draftAssistantState', JSON.stringify(stateToSave));
                console.log(`üíæ State saved: Round ${appState.currentRound}, Pick ${appState.currentPick}, Timer: ${appState.timerSeconds}s`);
            } catch (error) {
                console.error('‚ùå Failed to save state:', error);
            }
        }

        async function connectToESPN() {
            const leagueId = document.getElementById('leagueId').value;
            const seasonId = document.getElementById('seasonId').value;
            const espnS2 = document.getElementById('espnS2').value;
            const swid = document.getElementById('swid').value;

            if (!leagueId || !seasonId) {
                showStatus('Please enter League ID and Season Year', 'error');
                return;
            }

            const connectBtn = document.getElementById('connectBtn');
            connectBtn.disabled = true;
            connectBtn.innerHTML = '<span class="loading-spinner"></span> Connecting...';
            showStatus('Connecting to ESPN...', 'loading');

            try {
                const response = await fetch('/api/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        leagueId: parseInt(leagueId),
                        seasonId: parseInt(seasonId),
                        espnS2: espnS2 || null,
                        swid: swid || null
                    })
                });

                const result = await response.json();

                if (result.success) {
                    appState.connection = {
                        leagueId: parseInt(leagueId),
                        seasonId: parseInt(seasonId),
                        espnS2: espnS2,
                        swid: swid,
                        leagueInfo: result.league
                    };
                    
                    showStatus('‚úÖ Successfully connected to ESPN!', 'success');
                    
                    // Check if we already have league setup saved
                    if (appState.leagueSetup && appState.leagueSetup.size) {
                        console.log('üöÄ League setup exists - skipping to draft interface');
                        saveState();
                        
                        setTimeout(() => {
                            showScreen('draftInterface');
                            initializeDraft();
                        }, 1500);
                    } else {
                        // No league setup - go to setup screen
                        console.log('üìã No league setup - going to setup screen');
                        setTimeout(() => {
                            showScreen('leagueSetupScreen');
                            initializeLeagueSetup();
                        }, 1500);
                    }
                } else {
                    showStatus(`‚ùå ${result.error}`, 'error');
                }

            } catch (error) {
                console.error('Connection error:', error);
                showStatus('‚ùå Failed to connect. Check your internet connection.', 'error');
            } finally {
                connectBtn.disabled = false;
                connectBtn.innerHTML = 'Connect to ESPN League';
            }
        }

        function initializeLeagueSetup() {
            const leagueSizeSelect = document.getElementById('leagueSize');
            const teamCount = appState.connection.leagueInfo.teams || 10;
            leagueSizeSelect.value = teamCount;
            updateTeamInputs();
        }

        function updateTeamInputs() {
            const leagueSize = parseInt(document.getElementById('leagueSize').value);
            const teamSetup = document.getElementById('teamSetup');
            
            // Update draft position options
            const draftPosition = document.getElementById('myDraftPosition');
            const currentValue = draftPosition.value;
            draftPosition.innerHTML = '';
            for (let i = 1; i <= leagueSize; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}${i === 1 ? 'st' : i === 2 ? 'nd' : i === 3 ? 'rd' : 'th'} Pick`;
                draftPosition.appendChild(option);
            }
            if (currentValue <= leagueSize) {
                draftPosition.value = currentValue;
            }
            
            teamSetup.innerHTML = '';
            
            for (let i = 0; i < leagueSize; i++) {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-input';
                teamDiv.innerHTML = `
                    <input type="number" class="draft-order" value="${i + 1}" min="1" max="${leagueSize}" data-order="${i}">
                    <input type="text" placeholder="Team ${i + 1} Name" data-team="${i}" style="flex: 1;">
                `;
                teamSetup.appendChild(teamDiv);
            }
        }

        function saveLeagueSetup() {
            const leagueSize = parseInt(document.getElementById('leagueSize').value);
            const myDraftPosition = parseInt(document.getElementById('myDraftPosition').value) - 1; // 0-indexed
            const teams = [];
            
            for (let i = 0; i < leagueSize; i++) {
                const teamInput = document.querySelector(`input[data-team="${i}"]`);
                const orderInput = document.querySelector(`input[data-order="${i}"]`);
                
                teams.push({
                    id: i,
                    name: teamInput.value || `Team ${i + 1}`,
                    draftOrder: parseInt(orderInput.value) - 1,
                    isMyTeam: i === myDraftPosition
                });
            }
            
            // Sort teams by draft order
            teams.sort((a, b) => a.draftOrder - b.draftOrder);
            
            appState.leagueSetup = {
                size: leagueSize,
                teams: teams,
                myDraftPosition: myDraftPosition,
                myTeamId: myDraftPosition
            };
            
            saveState();
            showScreen('draftInterface');
            initializeDraft();
        }

        async function initializeDraft() {
            // Load players
            await loadPlayers();
            
            // Generate draft board
            generateDraftBoard();
            
            // Setup position tabs
            setupPositionTabs();
            
            // Initialize AI recommendations
            updateAIRecommendations();
            
            // Update my picks tracker
            updateMyPicksTracker();
            
            // Update current pick display
            updateCurrentPick();
            
            // Start timer with small delay to ensure DOM is ready
            setTimeout(() => {
                startTimer();
            }, 100);
        }

        async function loadPlayers() {
            try {
                showPlayersLoading();
                const response = await fetch(`/api/players/${appState.connection.seasonId}`);
                const players = await response.json();

                if (response.ok && Array.isArray(players)) {
                    appState.currentPlayers = players;
                    renderPlayers();
                    
                    // Update AI recommendations when players load
                    updateAIRecommendations();
                    
                    console.log(`‚úÖ Loaded ${players.length} players`);
                } else {
                    throw new Error('Failed to load players');
                }
            } catch (error) {
                console.error('‚ùå Error loading players:', error);
                showPlayersError();
            }
        }

        function generateDraftBoard() {
            const draftGrid = document.getElementById('draftGrid');
            const teamCount = appState.leagueSetup.size;
            const rounds = 16; // Standard fantasy draft rounds
            
            // Set CSS custom property for team count
            draftGrid.style.setProperty('--team-count', teamCount);
            
            let html = '<div class="round-header">RD</div>';
            
            // Team headers
            appState.leagueSetup.teams.forEach(team => {
                html += `<div class="team-header">${team.name.substring(0, 8)}</div>`;
            });
            
            // Draft slots
            for (let round = 1; round <= rounds; round++) {
                html += `<div class="round-header">${round}</div>`;
                
                for (let pick = 0; pick < teamCount; pick++) {
                    const isSnakeRound = round % 2 === 0;
                    const teamIndex = isSnakeRound ? teamCount - 1 - pick : pick;
                    const overallPick = (round - 1) * teamCount + pick + 1;
                    const isCurrent = overallPick === appState.currentPick;
                    
                    // Check if this slot is filled - FIXED LOGIC
                    const draftedPlayer = appState.draftPicks.find(p => p.overallPick === overallPick);
                    
                    let slotClass = 'draft-slot';
                    if (isCurrent && !draftedPlayer) slotClass += ' current';
                    if (draftedPlayer) slotClass += ' filled';
                    
                    html += `<div class="${slotClass}" data-round="${round}" data-pick="${pick + 1}" data-overall="${overallPick}" data-team="${teamIndex}">`;
                    
                    if (draftedPlayer) {
                        html += `
                            <div class="player-name">${draftedPlayer.playerName}</div>
                            <div class="player-details">${draftedPlayer.position} - ${draftedPlayer.team}</div>
                        `;
                    } else {
                        html += `<div style="font-size: 0.7rem; color: var(--text-secondary);">${overallPick}</div>`;
                    }
                    
                    html += '</div>';
                }
            }
            
            draftGrid.innerHTML = html;
        }

        function setupPositionTabs() {
            const tabs = document.querySelectorAll('.position-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    appState.selectedPosition = tab.dataset.position;
                    renderPlayers();
                });
            });
        }

        function renderPlayers() {
            const playersList = document.getElementById('playersList');
            
            if (!appState.currentPlayers || appState.currentPlayers.length === 0) {
                playersList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No players loaded</div>';
                return;
            }
            
            let filteredPlayers = appState.currentPlayers.filter(player => {
                // Position filter
                if (appState.selectedPosition !== 'ALL' && player.positionId.toString() !== appState.selectedPosition) {
                    return false;
                }
                
                // Search filter
                if (appState.searchTerm) {
                    const searchLower = appState.searchTerm.toLowerCase();
                    if (!player.name.toLowerCase().includes(searchLower) && 
                        !player.team.toLowerCase().includes(searchLower)) {
                        return false;
                    }
                }
                
                // Hide drafted players
                const isDrafted = appState.draftPicks.some(pick => pick.playerId === player.id);
                return !isDrafted;
            });
            
            // Sort by ADP
            filteredPlayers.sort((a, b) => {
                if (a.hasRealADP && b.hasRealADP) return a.adp - b.adp;
                if (a.hasRealADP && !b.hasRealADP) return -1;
                if (!a.hasRealADP && b.hasRealADP) return 1;
                return b.ownership - a.ownership;
            });
            
            const html = filteredPlayers.map(player => {
                return `
                    <div class="player-card" data-player-id="${player.id}">
                        <div class="player-card-header">
                            <div class="player-info">
                                ${player.name} <span style="color: var(--accent-orange);">${player.team} - ${player.position}</span>
                            </div>
                            <button class="draft-player-btn" onclick="draftPlayer(${player.id})">
                                Draft
                            </button>
                        </div>
                        <div class="player-stats">
                            ADP: ${player.adp !== 999 ? player.adp.toFixed(1) : 'N/A'} | 
                            Projected: ${player.projectedPoints.toFixed(1)} pts | 
                            Owned: ${player.ownership.toFixed(1)}%
                        </div>
                    </div>
                `;
            }).join('');
            
            playersList.innerHTML = html || '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No players found</div>';
        }

        function searchPlayers() {
            appState.searchTerm = document.getElementById('playerSearch').value;
            renderPlayers();
        }

        function draftPlayer(playerId) {
            const player = appState.currentPlayers.find(p => p.id === playerId);
            if (!player) return;
            
            // Calculate current team and overall pick
            const teamCount = appState.leagueSetup.size;
            const currentRound = appState.currentRound;
            const isSnakeRound = currentRound % 2 === 0;
            
            let teamIndex;
            if (isSnakeRound) {
                teamIndex = teamCount - ((appState.currentPick - 1) % teamCount) - 1;
            } else {
                teamIndex = (appState.currentPick - 1) % teamCount;
            }
            
            const overallPick = appState.currentPick;
            const draftingTeam = appState.leagueSetup.teams[teamIndex];
            
            // Add to draft picks
            const draftPick = {
                playerId: player.id,
                playerName: player.name,
                position: player.position,
                team: player.team,
                overallPick: overallPick,
                round: currentRound,
                teamId: draftingTeam.id,
                teamName: draftingTeam.name,
                timestamp: new Date().toISOString()
            };
            
            appState.draftPicks.push(draftPick);
            
            // Move to next pick
            appState.currentPick++;
            if (appState.currentPick > appState.currentRound * teamCount) {
                appState.currentRound++;
                if (appState.currentRound > 16) {
                    // Draft complete
                    clearInterval(appState.draftTimer);
                    alert('Draft Complete!');
                    return;
                }
            }
            
            // Save state and update UI
            saveState();
            generateDraftBoard();
            renderPlayers();
            updateCurrentPick();
            
            // Update AI recommendations after pick
            updateAIRecommendations();
            
            // Reset timer automatically when player is drafted
            resetTimer();
            
            console.log(`Drafted: ${player.name} to ${draftingTeam.name}`);
        }

        function updateCurrentPick() {
            const teamCount = appState.leagueSetup.size;
            const currentRound = appState.currentRound;
            const overallPick = appState.currentPick;
            const isSnakeRound = currentRound % 2 === 0;
            const pickInRound = ((overallPick - 1) % teamCount) + 1;
            
            let teamIndex;
            if (isSnakeRound) {
                teamIndex = teamCount - pickInRound;
            } else {
                teamIndex = pickInRound - 1;
            }
            
            const currentTeam = appState.leagueSetup.teams[teamIndex];
            
            document.getElementById('currentPick').textContent = 
                `Round ${currentRound}, Pick ${pickInRound} - ${currentTeam.name}`;
        }

        function updateMyPicksTracker() {
            const myRoster = aiEngine.getMyCurrentRoster();
            const myPickCount = myRoster.length;
            
            // Calculate next pick for my team
            const teamCount = appState.leagueSetup.size;
            const myDraftPosition = appState.leagueSetup.myDraftPosition;
            
            let nextPickRound = null;
            let nextPickNumber = null;
            
            // Find my next pick
            for (let round = appState.currentRound; round <= 16; round++) {
                for (let pick = 1; pick <= teamCount; pick++) {
                    const overallPick = (round - 1) * teamCount + pick;
                    if (overallPick <= appState.currentPick) continue; // Skip past picks
                    
                    const isSnakeRound = round % 2 === 0;
                    let teamIndex;
                    if (isSnakeRound) {
                        teamIndex = teamCount - pick;
                    } else {
                        teamIndex = pick - 1;
                    }
                    
                    if (teamIndex === myDraftPosition) {
                        nextPickRound = round;
                        nextPickNumber = pick;
                        break;
                    }
                }
                if (nextPickRound) break;
            }
            
            document.getElementById('myPickCount').textContent = myPickCount;
            if (nextPickRound) {
                document.getElementById('myNextPick').textContent = `Round ${nextPickRound}, Pick ${nextPickNumber}`;
            } else {
                document.getElementById('myNextPick').textContent = 'Draft Complete';
            }
        }

        function startTimer() {
            if (appState.draftTimer) clearInterval(appState.draftTimer);
            
            // Set timer start time if not already set (for new picks)
            if (!appState.timerStartTime) {
                appState.timerStartTime = Date.now();
                console.log(`‚è∞ Timer started for pick ${appState.currentPick}`);
            }
            
            appState.draftTimer = setInterval(() => {
                if (!appState.timerPaused) {
                    appState.timerSeconds--;
                    updateTimerDisplay();
                    
                    // Save state every 10 seconds to preserve timer
                    if (appState.timerSeconds % 10 === 0) {
                        saveState();
                    }
                    
                    // REMOVED AUTO-ADVANCE - Timer now just visual/audio alert
                    if (appState.timerSeconds <= 0) {
                        console.log(`‚è∞ Time expired for pick ${appState.currentPick} - Timer paused at 0:00`);
                        appState.timerPaused = true;
                        document.getElementById('pauseBtn').textContent = 'Resume';
                        document.getElementById('timer').classList.add('paused');
                        
                        // Optional: Add audio alert or visual notification
                        if (document.getElementById('timer')) {
                            document.getElementById('timer').style.background = 'var(--warning-red)';
                            document.getElementById('timer').style.animation = 'pulse 1s infinite';
                        }
                    }
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(appState.timerSeconds / 60);
            const seconds = appState.timerSeconds % 60;
            const timerEl = document.getElementById('timer');
            
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (appState.timerSeconds <= 30) {
                timerEl.style.background = 'var(--warning-red)';
            } else {
                timerEl.style.background = 'var(--success-green)';
            }
        }

        function pauseTimer() {
            appState.timerPaused = !appState.timerPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            const timer = document.getElementById('timer');
            
            if (appState.timerPaused) {
                pauseBtn.textContent = 'Resume';
                timer.classList.add('paused');
                console.log(`‚è∏Ô∏è Timer paused at ${appState.timerSeconds}s`);
            } else {
                pauseBtn.textContent = 'Pause';
                timer.classList.remove('paused');
                console.log(`‚ñ∂Ô∏è Timer resumed at ${appState.timerSeconds}s`);
            }
            
            // Save pause state immediately
            saveState();
        }

        function restartTimer() {
            console.log(`üîÑ Timer manually restarted for pick ${appState.currentPick}`);
            resetTimer();
        }

        function nextPick() {
            console.log(`‚û°Ô∏è Manually advancing to next pick`);
            
            // Move to next pick
            appState.currentPick++;
            if (appState.currentPick > appState.currentRound * appState.leagueSetup.size) {
                appState.currentRound++;
                if (appState.currentRound > 16) {
                    alert('Draft Complete!');
                    return;
                }
            }
            
            // Update UI
            updateCurrentPick();
            updateMyPicksTracker();
            generateDraftBoard();
            updateAIRecommendations();
            
            // Reset timer for next pick
            resetTimer();
            
            // Save state
            saveState();
            
            console.log(`‚úÖ Advanced to Round ${appState.currentRound}, Pick ${appState.currentPick}`);
        }

        function resetTimer() {
            appState.timerSeconds = 120;
            appState.timerStartTime = Date.now(); // Reset start time for new pick
            appState.timerPaused = false;
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('timer').classList.remove('paused');
            updateTimerDisplay();
            console.log(`‚è∞ Timer reset for pick ${appState.currentPick}`);
        }

        function showScreen(screenId) {
            document.querySelectorAll('.setup-screen, .draft-interface').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        function goToConnection() {
            showScreen('connectionScreen');
        }

        function showStatus(message, type) {
            const status = document.getElementById('connectionStatus');
            status.className = `status-message status-${type}`;
            status.textContent = message;
            status.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => status.classList.add('hidden'), 3000);
            }
        }

        function showPlayersLoading() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                    <div class="loading-spinner" style="margin: 0 auto 1rem;"></div>
                    Loading players from ESPN...
                </div>
            `;
        }

        function showPlayersError() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: var(--warning-red);">
                    <p>‚ùå Failed to load players</p>
                    <button class="btn" onclick="loadPlayers()" style="margin-top: 1rem;">
                        Retry Loading
                    </button>
                </div>
            `;
        }

        // Export draft data
        function exportDraft() {
            const draftData = {
                timestamp: new Date().toISOString(),
                leagueInfo: appState.connection.leagueInfo,
                leagueSetup: appState.leagueSetup,
                draftPicks: appState.draftPicks,
                currentRound: appState.currentRound,
                currentPick: appState.currentPick
            };
            
            const dataStr = JSON.stringify(draftData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `fantasy_draft_${appState.connection.seasonId}_${Date.now()}.json`;
            link.click();
            
            console.log('Draft exported successfully!');
        }

        function resetDraft() {
            if (confirm('üóëÔ∏è Are you sure you want to start a completely new draft? This will clear all current progress.')) {
                console.log('üóëÔ∏è Clearing all draft data...');
                
                // Clear localStorage completely
                localStorage.removeItem('draftAssistantState');
                
                // Reset all app state
                appState = {
                    connection: null,
                    leagueSetup: null,
                    currentPlayers: [],
                    draftPicks: [],
                    draftTimer: null,
                    timerSeconds: 120,
                    timerPaused: false,
                    currentRound: 1,
                    currentPick: 1,
                    selectedPosition: 'ALL',
                    searchTerm: ''
                };
                
                // Clear timer
                if (appState.draftTimer) {
                    clearInterval(appState.draftTimer);
                    appState.draftTimer = null;
                }
                
                // Reset timer state
                appState.timerSeconds = 120;
                appState.timerPaused = false;
                appState.timerStartTime = null;
                
                // Reset form fields
                document.getElementById('leagueId').value = '';
                document.getElementById('seasonId').value = '2025';
                document.getElementById('espnS2').value = '';
                document.getElementById('swid').value = '';
                
                // Go back to connection screen
                showScreen('connectionScreen');
                
                console.log('‚úÖ Draft session completely reset');
                alert('‚úÖ New draft session started! You can now set up a fresh draft.');
            }
        }

        // Keyboard shortcut for power users
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' && e.ctrlKey) {
                e.preventDefault();
                pauseTimer();
            }
            if (e.key === 'r' && e.ctrlKey) {
                e.preventDefault();
                restartTimer();
            }
            // Secret reset combo: Ctrl+Shift+R
            if (e.key === 'R' && e.ctrlKey && e.shiftKey) {
                e.preventDefault();
                resetDraft();
            }
        });

        // Auto-save every 30 seconds
        setInterval(saveState, 30000);

        // Save state before page unload
        window.addEventListener('beforeunload', saveState);
    </script>
</body>
</html>